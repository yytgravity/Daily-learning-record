## first

https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/modules/webaudio/base_audio_context.cc;l=356;drc=d81c5852498699fe3cd812e78d31c77c28e29281;bpv=0;bpt=1

```
void BaseAudioContext::HandleDecodeAudioData(
    AudioBuffer* audio_buffer,
    ScriptPromiseResolver* resolver,
    V8DecodeSuccessCallback* success_callback,
    V8DecodeErrorCallback* error_callback) {
  DCHECK(IsMainThread());

  if (!GetExecutionContext()) {
    // Nothing to do if the execution context is gone.
    return;
  }

  if (audio_buffer) {
    // Resolve promise successfully and run the success callback
    resolver->Resolve(audio_buffer);
    if (success_callback)
      success_callback->InvokeAndReportException(this, audio_buffer);
  } else {
    // Reject the promise and run the error callback
    auto* error = MakeGarbageCollected<DOMException>(
        DOMExceptionCode::kEncodingError, "Unable to decode audio data");
    resolver->Reject(error);
    if (error_callback)
      error_callback->InvokeAndReportException(this, error);
  }

  // We've resolved the promise.  Remove it now.
  DCHECK(decode_audio_resolvers_.Contains(resolver));
  decode_audio_resolvers_.erase(resolver);
}
```

æƒ³æ³•ï¼šresolver->Resolve(audio_buffer);åœ¨è¿™é‡Œé‡å…¥jsï¼Œç„¶åå›è°ƒé‡Œé€šè¿‡è§¦å‘frame detachï¼Œå¯ä»¥é€šè¿‡contextdestroyè¿™ä¸ªå‡½æ•°ï¼Œæ¥è®©é˜Ÿåˆ—è¢«clearï¼Œä¹‹ååœ¨decode_audio_resolvers_.erase(resolver);æ—¶ï¼š
```
template <typename T, typename U, typename V, typename W>
inline void HashSet<T, U, V, W>::erase(ValuePeekInType value) {
  erase(find(value));
}

template <typename T, typename U, typename V, typename W>
inline void HashSet<T, U, V, W>::erase(iterator it) {
  impl_.erase(it.impl_);
}

template <typename Key,
          typename Value,
          typename Extractor,
          typename HashFunctions,
          typename Traits,
          typename KeyTraits,
          typename Allocator>
template <typename HashTranslator, typename T>
inline typename HashTable<Key,
                          Value,
                          Extractor,
                          HashFunctions,
                          Traits,
                          KeyTraits,
                          Allocator>::const_iterator
HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits, Allocator>::
    Find(const T& key) const {
  const ValueType* entry = Lookup<HashTranslator>(key);
  if (!entry)
    return end();

  return MakeKnownGoodConstIterator(entry);
}
```
æ­¤æ—¶findä¼šè¿”å›endï¼Œå¦‚æœæ‰§è¡Œä¸‹é¢çš„ä»£ç ï¼š
```
template <typename Key,
          typename Value,
          typename Extractor,
          typename HashFunctions,
          typename Traits,
          typename KeyTraits,
          typename Allocator>
void HashTable<Key,
               Value,
               Extractor,
               HashFunctions,
               Traits,
               KeyTraits,
               Allocator>::erase(const ValueType* pos) {
  RegisterModification();
#if DUMP_HASHTABLE_STATS
  HashTableStats::instance().numRemoves.fetch_add(1, std::memory_order_relaxed);
#endif
#if DUMP_HASHTABLE_STATS_PER_TABLE
  stats_->numRemoves.fetch_add(1, std::memory_order_relaxed);
#endif

  EnterAccessForbiddenScope();
  DeleteBucket(*pos);
  LeaveAccessForbiddenScope();
  ++deleted_count_;
  --key_count_;

  if (ShouldShrink())
    Shrink();
}
```
å°±ä¼šåœ¨DeleteBucket(*pos);æ—¶äº§ç”Ÿæº¢å‡ºï¼Œä½†æ˜¯å¾ˆå¯æƒœï¼Œåœ¨åº•å±‚è¿˜æœ‰ä¸€ä¸ªcheckæ‰€ä»¥æ²¡äº†ï¼š
```
template <typename Key,
          typename Value,
          typename Extractor,
          typename HashFunctions,
          typename Traits,
          typename KeyTraits,
          typename Allocator>
inline void
HashTable<Key, Value, Extractor, HashFunctions, Traits, KeyTraits, Allocator>::
    erase(const_iterator it) {
  if (it == end())
    return;
  erase(it.position_);
}
```
åªæœ‰æ»¡è¶³äº†ifåˆ¤æ–­æ‰ä¼šæ‰§è¡Œåˆ°eraseã€‚

## second

å½“æˆ‘ä»¬ä½¿ç”¨äº†ä¸€ä¸ªè¢«å¼ƒç”¨çš„APIï¼Œå®ƒæœ€ç»ˆä¼šè°ƒåˆ°è¿™ä¸ªå‡½æ•°:
```
void Deprecation::CountDeprecation(ExecutionContext* context,
                                   WebFeature feature) {
  if (!context)
    return;

  Deprecation* deprecation = nullptr;
  if (auto* window = DynamicTo<LocalDOMWindow>(context)) {
    if (window->GetFrame())
      deprecation = &window->GetFrame()->GetPage()->GetDeprecation();
  } else if (auto* scope = DynamicTo<WorkerOrWorkletGlobalScope>(context)) {
    // TODO(crbug.com/1146824): Remove this once PlzDedicatedWorker and
    // PlzServiceWorker ship.
    if (!scope->IsInitialized()) {
      return;
    }
    deprecation = &scope->GetDeprecation();
  }

  if (!deprecation || deprecation->mute_count_ ||
      deprecation->GetReported(feature)) {
    return;
  }
  deprecation->SetReported(feature);

  // Don't count usage of WebComponentsV0 for chrome:// URLs, but still report
  // the deprecation messages.
  bool count_usage = true;
  if (context->Url().ProtocolIs("chrome") &&
      (feature == WebFeature::kHTMLImports ||
       feature == WebFeature::kElementCreateShadowRoot ||
       feature == WebFeature::kDocumentRegisterElement)) {
    count_usage = false;
  }
  if (count_usage)
    context->CountUse(feature);

  const DeprecationInfo info = GetDeprecationInfo(feature);

  // Send the deprecation message to the console as a warning.
  DCHECK(!info.message.IsEmpty());
  auto* console_message = MakeGarbageCollected<ConsoleMessage>(
      mojom::ConsoleMessageSource::kDeprecation,
      mojom::ConsoleMessageLevel::kWarning, info.message);
  context->AddConsoleMessage(console_message);

  Report* report = CreateReportInternal(context->Url(), info);

  // Send the deprecation report to the Reporting API and any
  // ReportingObservers.
  ReportingContext::From(context)->QueueReport(report);
}
```

æœ‰ä¸€ä¸ªapiï¼ˆhttps://developer.mozilla.org/en-US/docs/Web/API/ReportingObserver ï¼‰ å¯ä»¥ç”¨æ¥æ”¶é›†å’Œè®¿é—®æŠ¥å‘Šã€‚ 

æˆ‘ä»¬é‡ç‚¹çœ‹è¿™é‡Œï¼š
ReportingContext::From(context)->QueueReport(report);

```
void ReportingContext::QueueReport(Report* report,
                                   const Vector<String>& endpoints) {
  CountReport(report);

  NotifyInternal(report);

  // Send the report via the Reporting API.
  for (auto& endpoint : endpoints)
    SendToReportingAPI(report, endpoint);
}
```
```
void ReportingContext::NotifyInternal(Report* report) {
  // Buffer the report.
  if (!report_buffer_.Contains(report->type())) {
    report_buffer_.insert(
        report->type(),
        MakeGarbageCollected<HeapListHashSet<Member<Report>>>());
  }
  report_buffer_.find(report->type())->value->insert(report);

  // Only the most recent 100 reports will remain buffered, per report type.
  // https://w3c.github.io/reporting/#notify-observers
  if (report_buffer_.at(report->type())->size() > 100)
    report_buffer_.find(report->type())->value->RemoveFirst();

  // Queue the report in all registered observers.
  for (auto observer : observers_)
    observer->QueueReport(report);
}
```
```
void ReportingObserver::QueueReport(Report* report) {
  if (!ObservedType(report->type()))
    return;

  report_queue_.push_back(report);

  // When the first report of a batch is queued, make a task to report the whole
  // batch.
  if (report_queue_.size() == 1) {
    execution_context_->GetTaskRunner(TaskType::kMiscPlatformAPI)
        ->PostTask(FROM_HERE, WTF::Bind(&ReportingObserver::ReportToCallback,
                                        WrapWeakPersistent(this)));
  }
}
```
```
void ReportingObserver::ReportToCallback() {
  // The reports queued to be sent to callbacks are copied (and cleared) before
  // being sent, since additional reports may be queued as a result of the
  // callbacks.
  auto reports_to_send = report_queue_;
  report_queue_.clear();
  callback_->InvokeAndReportException(this, reports_to_send, this);
}
```

çœ‹ä¸Šé¢çš„ä»£ç å¯ä»¥çŸ¥é“ReportToCallbackæ˜¯é€šè¿‡posttaskåˆ°å¦ä¸€ä¸ªçº¿ç¨‹å»è°ƒçš„å›è°ƒçš„ï¼Œè€Œä¸”è¯¥å‡½æ•°callback_->InvokeAndReportException(this, reports_to_send, this);å¯ä»¥é‡å…¥åˆ°jsã€‚

æ‰€ä»¥è¿™é‡Œæœ‰äº†ä¸€ä¸ªæƒ³æ³•å°±æ˜¯è®©ReportToCallbackå’ŒNotifyInternalä¸­çš„for (auto observer : observers_)äº§ç”Ÿä¸€ä¸ªæ¡ä»¶ç«äº‰ï¼Œé€šè¿‡åœ¨å›è°ƒé‡Œå¢åŠ observe()ä½¿observers_é‡æ–°åˆ†é…ï¼Œè¾¾åˆ°è¿­ä»£å™¨å¤±æ•ˆçš„ç›®çš„ã€‚
```
void ReportingObserver::observe() {
  registered_ = true;
  ReportingContext::From(execution_context_)->RegisterObserver(this);
}
```
å¤±è´¥åŸå› ï¼šposttaskè²Œä¼¼å¯ä»¥é¿å…æ¡ä»¶ç«äº‰ï¼ŒåŸå› ä¸æ˜ğŸ˜‚

pocï¼š
```
<html>

  <p><button onclick="geoFindMe()">Show my location</button></p>
  <div id="out"></div>

  <script>
  
  const observer = new ReportingObserver((reports, observer) => {
    for (let i = 0; i < 0x100; i++)
    {
        observer.observe();
    }
  }, {buffered: true});

  observer.observe();

  function geoFindMe() {
  var output = document.getElementById("out");

  if (!navigator.geolocation){
    output.innerHTML = "<p>æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒåœ°ç†ä½ç½®</p>";
    return;
  }

  function success(position) {
    var latitude  = position.coords.latitude;
    var longitude = position.coords.longitude;

    output.innerHTML = '<p>Latitude is ' + latitude + 'Â° <br>Longitude is ' + longitude + 'Â°</p>';

    var img = new Image();
    img.src = "http://maps.googleapis.com/maps/api/staticmap?center=" + latitude + "," + longitude + "&zoom=13&size=300x300&sensor=false";

    output.appendChild(img);
  };

  function error() {
    output.innerHTML = "æ— æ³•è·å–æ‚¨çš„ä½ç½®";
  };

  output.innerHTML = "<p>Locatingâ€¦</p>";

  navigator.geolocation.getCurrentPosition(success, error);
  }

  </script>

</html>

```
è¦è§¦å‘Deprecation::CountDeprecationéœ€è¦ä¸€ä¸ªä¸å®‰å…¨çš„ä¸Šä¸‹æ–‡ä¹Ÿå°±æ˜¯éœ€è¦æ”¾åˆ°httpæœåŠ¡å™¨ä¸Šã€‚

```
void Geolocation::RecordOriginTypeAccess() const {
  DCHECK(GetFrame());

  LocalDOMWindow* window = DomWindow();

  // It is required by isSecureContext() but isn't actually used. This could be
  // used later if a warning is shown in the developer console.
  String insecure_origin_msg;
  if (window->IsSecureContext(insecure_origin_msg)) {
    UseCounter::Count(window, WebFeature::kGeolocationSecureOrigin);
    window->CountUseOnlyInCrossOriginIframe(
        WebFeature::kGeolocationSecureOriginIframe);
  } else if (GetFrame()
                 ->GetSettings()
                 ->GetAllowGeolocationOnInsecureOrigins()) {
    // Android WebView allows geolocation in secure contexts for legacy apps.
    // See https://crbug.com/603574 for details.
    Deprecation::CountDeprecation(
        window, WebFeature::kGeolocationInsecureOriginDeprecatedNotRemoved);
    Deprecation::CountDeprecationCrossOriginIframe(
        window,
        WebFeature::kGeolocationInsecureOriginIframeDeprecatedNotRemoved);
  } else {
    Deprecation::CountDeprecation(window,
                                  WebFeature::kGeolocationInsecureOrigin);
    Deprecation::CountDeprecationCrossOriginIframe(
        window, WebFeature::kGeolocationInsecureOriginIframe);
  }
}
```

## third

https://bugs.chromium.org/p/chromium/issues/detail?id=1074706